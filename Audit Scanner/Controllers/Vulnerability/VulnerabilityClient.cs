using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Threading;
using Audit_Scanner.Models;
using Audit_Scanner.Vulnerability.Models;
using MoreLinq.Extensions;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using RestSharp;
using SaltwaterTaffy.Container;

namespace Audit_Scanner.Controllers.Vulnerability
{
    public class VulnerabilityClient
    {
        private const string _APIKEY = "cucp3O302CEzMWwJ87HA40y8q5f5GDS3";

        public List<DeviceModel> ScanVulnerabilities(List<Host> devices)
        {
            RestClient restClient = new RestClient("https://exploits.shodan.io/");
            RestRequest restRequest = new RestRequest("api/search", Method.GET);
            restRequest.AddParameter("key", _APIKEY);

            var vulnerableDevices = new List<DeviceModel>();

            foreach (var device in devices)
            {
                var vulnerabilities = new List<VulnerabilityModel>();

                foreach (var port in device.Ports)
                {
                    var product = "";
                    var version = "";

                    if (port.Service.Version == null && port.Service.Product == null)
                    {
                        continue;
                    }

                    if (port.Service.Version != null)
                    {
                        version = port.Service.Version.Substring(0,
                            port.Service.Version.IndexOf(" ", StringComparison.Ordinal) + 1);
                    }

                    var searchTerm = $"{port.Service.Product} {version}";
                    restRequest.AddParameter("query", searchTerm);
                    
                    // Limited to 1 request per second with Shodan, in case a request returns no results we'll wait 1 second before the next.
                    Thread.Sleep(1000);
                    
                    var query = restClient.Execute((IRestRequest) restRequest);
                    JObject parsedQuery;

                    try
                    {
                        parsedQuery = JObject.Parse(query.Content);
                        var array = parsedQuery.GetValue("matches");

                        foreach (var jObject in array)
                        {
                            var vulnerability = new VulnerabilityModel();

                            vulnerability.Port = port.PortNumber;
                            vulnerability.Service =
                                $"{port.Service.Name} ({port.Service.Product})";
                            vulnerability.Version = port.Service.Version;
                            if (jObject["source"] != null) vulnerability.Source = jObject["source"].ToString();
                            if (jObject["type"] != null) vulnerability.Type = jObject["type"].ToString();
                            if (jObject["cve"] != null && jObject["cve"].HasValues)  vulnerability.CVE = jObject["cve"].ToObject<string[]>()[0];
                            if (jObject["date"] != null) vulnerability.Date = DateTime.Parse(jObject["date"].ToString());

                            if (jObject["description"] != null)
                            {
                                var description = jObject["description"].ToString();
                                if (description.Length > 100)
                                {
                                    //Truncate long descriptions to display to users.
                                    var tempString = description.Substring(0, 100);
                                    if (tempString.LastIndexOf(' ') > 0)
                                    {
                                        description = tempString.Substring(0, tempString.LastIndexOf(' ')) + " ...";
                                    }
                                }

                                vulnerability.Description = description;
                            }

                            vulnerabilities.Add(vulnerability);
                        }
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine($"There was an error during the search.");
                    }
                }

                if (vulnerabilities.Any())
                {
                    var vulnerableDevice = new DeviceModel();
                    vulnerableDevice.IP = device.Address.ToString();
                    vulnerableDevice.PhysicalAddress = device.PhysicalAddress;
                    vulnerableDevice.Vendor = device.Vendor;

                    try
                    {
                        vulnerableDevice.Hostname = Dns.GetHostEntry(device.Address).HostName;
                    }
                    catch (Exception e)
                    {
                        //GetHostEntry throws an exception if host not found.
                        vulnerableDevice.Hostname = "Hostname not found.";
                    }

                    // Remove duplicate instances of vulnerabilities by CVE
                    var vulnerabilitiesTest = vulnerabilities.DistinctBy(x => x.CVE).ToList();
                    
                    //Only keep top 5 most recent vulnerabilities
                    vulnerabilities = vulnerabilities.Where(x => x.Date.HasValue)
                        .OrderByDescending(x => x.Date.Value)
                        .Take(5).ToList();
                    
                    vulnerableDevice.Vulnerabilities = vulnerabilities;

                    vulnerableDevices.Add(vulnerableDevice);
                }
            }

            return vulnerableDevices;
        }
    }
}